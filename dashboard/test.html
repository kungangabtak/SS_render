<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard Tests</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
    }
    .test {
      margin: 10px 0;
      padding: 10px;
      border: 1px solid #444;
      border-radius: 4px;
    }
    .pass {
      background: #0a4;
      color: white;
    }
    .fail {
      background: #a40;
      color: white;
    }
    .test-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .test-result {
      margin-top: 5px;
    }
    h1 {
      color: #fff;
    }
    .summary {
      margin-top: 20px;
      padding: 15px;
      border-radius: 4px;
      font-size: 18px;
      font-weight: bold;
    }
    .summary.pass {
      background: #0a4;
    }
    .summary.fail {
      background: #a40;
    }
  </style>
</head>
<body>
  <h1>Dashboard Test Suite</h1>
  <div id="test-results"></div>
  <div id="summary"></div>

  <script type="module">
    // Import the functions we need to test
    // Since we can't easily import from app.js in a test context,
    // we'll test the logic by creating test versions

    const tests = [];
    let passed = 0;
    let failed = 0;

    function test(name, fn) {
      try {
        fn();
        tests.push({ name, passed: true });
        passed++;
      } catch (e) {
        tests.push({ name, passed: false, error: e.message });
        failed++;
      }
    }

    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || "Assertion failed");
      }
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, got ${actual}`);
      }
    }

    // Test extractGameId
    test("extractGameId: extracts from full URL", () => {
      const input = "https://www.pokernow.club/games/pglQ2HgWGgYbDUSq7f9moVbXR";
      const match = input.match(/\/games\/([a-zA-Z0-9_-]+)/);
      assert(match && match[1] === "pglQ2HgWGgYbDUSq7f9moVbXR", "Should extract game ID");
    });

    test("extractGameId: returns raw input if not URL", () => {
      const input = "pglQ2HgWGgYbDUSq7f9moVbXR";
      const match = input.match(/\/games\/([a-zA-Z0-9_-]+)/);
      assert(!match, "Should not match non-URL");
    });

    // Test buildWsUrl logic
    test("buildWsUrl: creates URL without token", () => {
      const hub = "wss://dom-hub.onrender.com";
      const gameId = "test123";
      const token = "";
      
      let hubStr = String(hub || "").trim();
      if (!/^wss?:\/\//i.test(hubStr)) {
        hubStr = `wss://${hubStr}`;
      }
      const u = new URL(hubStr);
      u.searchParams.set("role", "sub");
      u.searchParams.set("room", gameId);
      
      const tokenValue = String(token || "").trim();
      if (tokenValue) {
        u.searchParams.set("token", tokenValue);
      }
      
      const url = u.toString();
      assert(url.includes("role=sub"), "Should include role=sub");
      assert(url.includes("room=test123"), "Should include room");
      assert(!url.includes("token="), "Should not include token when empty");
    });

    test("buildWsUrl: creates URL with token", () => {
      const hub = "wss://dom-hub.onrender.com";
      const gameId = "test123";
      const token = "abc123";
      
      let hubStr = String(hub || "").trim();
      if (!/^wss?:\/\//i.test(hubStr)) {
        hubStr = `wss://${hubStr}`;
      }
      const u = new URL(hubStr);
      u.searchParams.set("role", "sub");
      u.searchParams.set("room", gameId);
      
      const tokenValue = String(token || "").trim();
      if (tokenValue) {
        u.searchParams.set("token", tokenValue);
      }
      
      const url = u.toString();
      assert(url.includes("token=abc123"), "Should include token when provided");
    });

    // Test message handling - snapshot
    test("handleIncomingMessage: processes snapshot messages", () => {
      const snapshotMsg = {
        type: "snapshot",
        data: {
          hand: {
            publisherId: "pub1",
            playerName: "Player1",
            type: "hand",
            data: { value1: "A", suit1: "h", value2: "K", suit2: "d" }
          },
          state: {
            publisherId: "pub1",
            type: "state",
            data: { status: "active" }
          }
        }
      };
      
      assert(snapshotMsg.type === "snapshot", "Should identify snapshot");
      assert(snapshotMsg.data && typeof snapshotMsg.data === "object", "Should have data object");
      assert(Object.keys(snapshotMsg.data).length === 2, "Should have multiple messages");
    });

    // Test message handling - regular message
    test("handleIncomingMessage: processes regular messages", () => {
      const regularMsg = {
        publisherId: "pub1",
        playerName: "Player1",
        type: "hand",
        data: { value1: "A", suit1: "h", value2: "K", suit2: "d" },
        timestamp: Date.now()
      };
      
      assert(regularMsg.publisherId === "pub1", "Should have publisherId");
      assert(regularMsg.type === "hand", "Should have type");
      assert(regularMsg.data, "Should have data");
    });

    // Test error code handling
    test("Error code 4001: invalid role", () => {
      const code = 4001;
      assert(code === 4001, "Should identify 4001");
    });

    test("Error code 4002: invalid token", () => {
      const code = 4002;
      assert(code === 4002, "Should identify 4002");
    });

    test("Error code 4003: token expired", () => {
      const code = 4003;
      assert(code === 4003, "Should identify 4003");
    });

    test("Error code 4004: claim mismatch", () => {
      const code = 4004;
      assert(code === 4004, "Should identify 4004");
    });

    // Test publisherId extraction
    test("publisherId extraction: falls back to unknown", () => {
      const msg1 = { publisherId: "pub1", type: "hand" };
      const msg2 = { type: "hand" }; // no publisherId
      
      const id1 = msg1.publisherId || "unknown";
      const id2 = msg2.publisherId || "unknown";
      
      assertEqual(id1, "pub1", "Should use provided publisherId");
      assertEqual(id2, "unknown", "Should fallback to unknown");
    });

    // Test URL token masking
    test("Token masking in logs", () => {
      const url = "wss://hub.com/?role=sub&room=test&token=secret123";
      const masked = url.replace(/token=[^&]+/, 'token=***');
      assert(!masked.includes("secret123"), "Should mask token");
      assert(masked.includes("token=***"), "Should show masked token");
    });

    // Test normalizeValue
    test("normalizeValue: handles null", () => {
      const result = null == null ? "—" : String(null).trim().toUpperCase();
      assertEqual(result, "—", "Should return — for null");
    });

    test("normalizeValue: handles empty string", () => {
      const s = String("").trim();
      const result = s.length === 0 ? "—" : s.toUpperCase();
      assertEqual(result, "—", "Should return — for empty string");
    });

    // Test suitSymbol
    test("suitSymbol: converts correctly", () => {
      const suits = { h: "♥", d: "♦", c: "♣", s: "♠" };
      assertEqual(suits.h, "♥", "Hearts should be ♥");
      assertEqual(suits.d, "♦", "Diamonds should be ♦");
      assertEqual(suits.c, "♣", "Clubs should be ♣");
      assertEqual(suits.s, "♠", "Spades should be ♠");
    });

    // Test reconnect logic
    test("Reconnect delay calculation", () => {
      const RECONNECT_CAP_MS = 10000;
      const RECONNECT_BASE_MS = 500;
      const attempt = 3;
      
      const delay = Math.min(RECONNECT_CAP_MS, RECONNECT_BASE_MS * Math.pow(2, attempt));
      assert(delay === 4000, "Should calculate exponential backoff");
    });

    test("Reconnect delay caps at max", () => {
      const RECONNECT_CAP_MS = 10000;
      const RECONNECT_BASE_MS = 500;
      const attempt = 10; // high attempt
      
      const delay = Math.min(RECONNECT_CAP_MS, RECONNECT_BASE_MS * Math.pow(2, attempt));
      assert(delay === 10000, "Should cap at RECONNECT_CAP_MS");
    });

    // Render results
    const resultsDiv = document.getElementById("test-results");
    const summaryDiv = document.getElementById("summary");
    
    tests.forEach(t => {
      const div = document.createElement("div");
      div.className = `test ${t.passed ? "pass" : "fail"}`;
      div.innerHTML = `
        <div class="test-name">${t.passed ? "✓" : "✗"} ${t.name}</div>
        ${t.error ? `<div class="test-result">Error: ${t.error}</div>` : ""}
      `;
      resultsDiv.appendChild(div);
    });

    const summary = document.createElement("div");
    summary.className = `summary ${failed === 0 ? "pass" : "fail"}`;
    summary.textContent = `Tests: ${passed} passed, ${failed} failed (${tests.length} total)`;
    summaryDiv.appendChild(summary);

    console.log(`Tests: ${passed} passed, ${failed} failed (${tests.length} total)`);
  </script>
</body>
</html>

